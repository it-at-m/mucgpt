import logging
import textwrap

from langchain_core.messages import SystemMessage
from langchain_core.runnables.base import RunnableSerializable
from langchain_core.tools import tool
from langgraph.config import get_stream_writer

from agent.tools.brainstorm import brainstorming
from agent.tools.simplify import simplify
from agent.tools.tool_chunk import ToolStreamChunk, ToolStreamState
from api.api_models import ToolInfo, ToolListResponse
from core.logtools import getLogger

# Centralized single-line summaries to avoid duplication across decorator, metadata and system prompt
BRAINSTORMING_SUMMARY = "Generates or refines a detailed markdown mind map."  # one-line
SIMPLIFY_SUMMARY = (
    "Simplifies complex German text to A2 Easy Language (Leichte Sprache)."  # one-line
)

# Detailed instruction templates (dedented for clean system prompts)
BRAINSTORMING_DETAILED = textwrap.dedent(
    """
    **Brainstorming**

    Description: Generates or refines a detailed mind map (pure markdown; no code fences).

    Use for:
    • New idea exploration
    • Organizing complex / hierarchical domains
    • Structured refinement based on user feedback

    Technical:
    • Hierarchical markdown (headings + bullet lists)
    • 4–7 main branches recommended; 2–4 nested levels where meaningful
    • Bold only once for central concept line

    Parameters:
    - topic (required)
    - context (optional) Supplemental info to integrate selectively
    - existing_mindmap (optional) Full previous map for refinement
    - feedback (optional) Specific change requests

    Best Practices:
    - In refinement: keep unchanged branches stable; modify only targeted areas
    - Avoid generic placeholders (e.g., "Misc")
    - Prefer parallel grammatical structure for sibling nodes
    - Reference earlier output blocks shown as ```MUCGPTBrainstorming ...``` when refining.
    """
)

SIMPLIFY_DETAILED = textwrap.dedent(
    """
    **Vereinfachen (Simplify)**

    Description: Converts German text to A2 level (Leichte Sprache) while preserving meaning.

    Use for:
    • Accessibility
    • Language learning support
    • Plain-language rewrites

    Technical:
    • Short sentences (≤15 words), active voice, concrete vocabulary
    • Blank lines separate logical units
    • Preserve factual accuracy; no omissions

    Parameter:
    - text (required) Entire source text (single call; do not split)

    Best Practices:
    - Reject fragments; request full text if incomplete
    - Keep proper nouns; explain only if ambiguous
    - No idioms, passive voice, nested clauses
    - Reference earlier output blocks shown as ```MUCGPTVereinfachen ...``` when user wants adjustments.
    """
)

TOOL_INSTRUCTIONS_TEMPLATE = """
# Tools
## Available tools:
{tool_descriptions}

{tool_detailed_instructions}
## Tool outputs in conversation
Previous tool outputs appear in the conversation history as custom markdown code blocks.
Each tool's output is wrapped in a specific format for easy identification:

```MUCGPTBrainstorming
Mind map content generated by the Brainstorming tool
...
```

```MUCGPTVereinfachen
Simplified text produced by the Vereinfachen tool
...
```

You can reference these outputs in your responses when needed. The markdown format clearly indicates which tool produced which content.

## Tool guidelines
- Invoke a tool only when it clearly advances the user's request.
- At most one tool call per user message.
- If no tool is suitable, answer directly without a tool call.

"""


def make_brainstorm_tool(model: RunnableSerializable, logger: logging.Logger = None):
    @tool(
        "Brainstorming",
        description=BRAINSTORMING_SUMMARY,
    )
    def brainstorm_tool(
        topic: str,
        context: str = None,
        existing_mindmap: str = None,
        feedback: str = None,
    ):
        writer = get_stream_writer()
        if existing_mindmap:
            writer(
                ToolStreamChunk(
                    state=ToolStreamState.STARTED,
                    content=f"Verbessere Brainstorming für Thema: {topic} basierend auf Feedback",
                    tool_name="Brainstorming",
                ).model_dump_json()
            )
        else:
            writer(
                ToolStreamChunk(
                    state=ToolStreamState.STARTED,
                    content=f"Starte Brainstorming für Thema: {topic}",
                    tool_name="Brainstorming",
                ).model_dump_json()
            )
        result = brainstorming(
            topic, context, model, logger, writer, existing_mindmap, feedback
        )
        writer(
            ToolStreamChunk(
                state=ToolStreamState.ENDED,
                content="Brainstorming abgeschlossen.",
                tool_name="Brainstorming",
            ).model_dump_json()
        )
        return result

    return brainstorm_tool


def make_simplify_tool(model: RunnableSerializable, logger: logging.Logger = None):
    @tool(
        "Vereinfachen",
        description=SIMPLIFY_SUMMARY,
    )
    def simplify_tool(text: str):
        writer = get_stream_writer()
        result = simplify(text, model, logger, writer=writer)
        return result

    return simplify_tool


class ToolCollection:
    """Collection of chat tools for brainstorming and simplification."""

    def __init__(self, model: RunnableSerializable, logger: logging.Logger = None):
        self.model = model
        self.logger = logger or getLogger(name="mucgpt-core-tools")
        self._brainstorm_tool = make_brainstorm_tool(self.model, self.logger)
        self._simplify_tool = make_simplify_tool(self.model, self.logger)

    @property
    def simplify(self):
        return self._simplify_tool

    @property
    def brainstorm(self):
        return self._brainstorm_tool

    def get_tools(self):
        """Return a list of all tool callables."""
        return [self._brainstorm_tool, self._simplify_tool]

    def get_all(self, enabled_tools: list[str] = None) -> list:
        """Return a list of tools, optionally filtered by enabled_tools."""
        all_tools = [self._brainstorm_tool, self._simplify_tool]
        if enabled_tools:
            return self.filter_tools_by_names(enabled_tools)
        return all_tools

    def filter_tools_by_names(self, tool_names: list[str]) -> list:
        """Return only tools whose name is in tool_names."""
        return [tool for tool in self.get_all() if tool.name in tool_names]

    @staticmethod
    def list_tool_metadata(lang: str = "Deutsch") -> ToolListResponse:
        """
        Dynamically returns metadata for all available tools, including their name and description, without requiring a model.
        Args:
            lang (str, optional): The language for the tool metadata. Defaults to "Deutsch".
        Returns:
            ToolListResponse: An object containing a list of ToolInfo instances, each representing a tool's id, name, and description.
        """

        class DummyModel(RunnableSerializable):
            def with_config(self, *args, **kwargs):
                return self

            def with_structured_output(self, *args, **kwargs):
                return self

            def __init__(self):
                self.__pregel_runtime = {}

            def invoke(self, *args, **kwargs):
                return type("DummyResponse", (), {"content": ""})()

        dummy_logger = getLogger(
            name="dummy"
        )  # Define tool metadata with languages as top-level keys
        tool_metadata = {
            "deutsch": {
                "Brainstorming": {
                    "name": "Brainstorming",
                    "description": "Erstellt oder verbessert eine detaillierte Mindmap zu einem Thema im Markdown-Format, basierend auf Nutzer-Feedback.",
                },
                "Vereinfachen": {
                    "name": "Vereinfachen",
                    "description": "Vereinfacht komplexe deutsche Texte auf A2-Niveau nach Prinzipien der Leichten Sprache.",
                },
            },
            "english": {
                "Brainstorming": {
                    "name": "Brainstorming",
                    "description": "Generates or refines a detailed mind map for a given topic in markdown format based on user feedback.",
                },
                "Vereinfachen": {
                    "name": "Simplify",
                    "description": "Simplifies complex German text to A2 level using Easy Language principles.",
                },
            },
            "français": {
                "Brainstorming": {
                    "name": "Remue-méninges",
                    "description": "Génère ou améliore une carte mentale détaillée pour un sujet donné au format markdown selon les commentaires de l'utilisateur.",
                },
                "Vereinfachen": {
                    "name": "Simplifier",
                    "description": "Simplifie les textes allemands complexes au niveau A2 selon les principes du langage facile.",
                },
            },
            "bairisch": {
                "Brainstorming": {
                    "name": "Brainstorming",
                    "description": "Macht a genaue Mindmap zu am Thema im Markdown-Format oder verbessert eine, wenn da Nutzer Feedback gibt.",
                },
                "Vereinfachen": {
                    "name": "Eifacher machen",
                    "description": "Macht schwere deutsche Text eifacher auf A2-Level mit da Leichten Sprach.",
                },
            },
            "ukrainisch": {
                "Brainstorming": {
                    "name": "Мозковий штурм",
                    "description": "Створює або вдосконалює детальну ментальну карту для заданої теми у форматі markdown на основі відгуків користувачів.",
                },
                "Vereinfachen": {
                    "name": "Спростити",
                    "description": "Спрощує складні німецькі тексти до рівня A2 за принципами простої мови.",
                },
            },
        }

        # Determine language key
        lang_key = "deutsch"
        if lang.lower() == "english":
            lang_key = "english"
        elif lang.lower() in ["français", "francais", "french"]:
            lang_key = "français"
        elif lang.lower() in ["bairisch", "bavarian", "bayerisch"]:
            lang_key = "bairisch"
        elif lang.lower() in ["українська", "ukrainisch", "ukrainian"]:
            lang_key = "ukrainisch"

        # Create tool instances
        brainstorm_tool = make_brainstorm_tool(DummyModel(), dummy_logger)
        simplify_tool = make_simplify_tool(DummyModel(), dummy_logger)

        # Build the list using actual tool names for lookup
        tools = []
        for tool_id in [brainstorm_tool, simplify_tool]:
            tool_name = tool_id.name
            meta = tool_metadata.get(lang_key, {}).get(tool_name)
            if meta:
                tools.append(
                    ToolInfo(
                        id=tool_name,
                        name=meta.get("name", tool_name),
                        description=meta.get("description", tool_id.description),
                    )
                )
            else:
                # fallback to tool's own name/description
                tools.append(
                    ToolInfo(
                        id=tool_name, name=tool_name, description=tool_id.description
                    )
                )
        return ToolListResponse(tools=tools)

    def add_instructions(self, messages, enabled_tools):
        """Inject a system message describing available tools with concise summaries and detailed guidance."""
        if not enabled_tools:
            return messages

        # Map tool name to detailed block
        detailed_map = {
            "Brainstorming": BRAINSTORMING_DETAILED,
            "Vereinfachen": SIMPLIFY_DETAILED,
        }

        tool_descriptions = []  # single-line summaries
        tool_detailed_instructions = []

        for t in enabled_tools:
            tool_obj = None
            if hasattr(t, "name") and hasattr(t, "description"):
                tool_obj = t
            else:
                tool_obj = next(
                    (tool for tool in self.get_all() if tool.name == t), None
                )
            if not tool_obj:
                continue
            summary = tool_obj.description.strip().replace("\n", " ")
            tool_descriptions.append(f"- {tool_obj.name}: {summary}")
            detailed = detailed_map.get(tool_obj.name)
            if detailed:
                tool_detailed_instructions.append(detailed.strip())

        if not tool_descriptions:
            return messages

        tool_instructions = TOOL_INSTRUCTIONS_TEMPLATE.format(
            tool_descriptions="\n".join(tool_descriptions),
            tool_detailed_instructions="\n\n".join(tool_detailed_instructions),
        )

        if messages and isinstance(messages[0], SystemMessage):
            messages[0] = SystemMessage(
                content=f"{messages[0].content}\n\n{tool_instructions}"
            )
        else:
            messages.insert(0, SystemMessage(content=tool_instructions))
        return messages
