import logging
import textwrap

from langchain_core.messages import SystemMessage
from langchain_core.runnables.base import RunnableSerializable
from langchain_core.tools import tool
from langgraph.config import get_stream_writer

from agent.tools.brainstorm import brainstorming
from agent.tools.simplify import simplify
from agent.tools.tool_chunk import ToolStreamChunk, ToolStreamState
from api.api_models import ToolInfo, ToolListResponse
from core.logtools import getLogger

TOOL_INSTRUCTIONS_TEMPLATE = """
# Tools
## Available tools:
{tool_descriptions}

{tool_detailed_instructions}
## Tool outputs in conversation
Previous tool outputs appear in the conversation history as custom markdown code blocks.
Each tool's output is wrapped in a specific format for easy identification:

```MUCGPTBrainstorming
Mind map content generated by the Brainstorming tool
...
```

```MUCGPTVereinfachen
Simplified text produced by the Vereinfachen tool
...
```

You can reference these outputs in your responses when needed. The markdown format clearly indicates which tool produced which content.

## Tool guidelines
- Invoke a tool only when it clearly advances the user's request.
- At most one tool call per user message.
- If no tool is suitable, answer directly without a tool call.

"""

class ToolCollection:
    """Collection of chat tools for brainstorming and simplification."""

    def __init__(self, model: RunnableSerializable, logger: logging.Logger = None):
        self.model = model
        self.logger = logger or getLogger(name="mucgpt-core-tools")
        self._brainstorm_tool = make_brainstorm_tool(self.model, self.logger)
        self._simplify_tool = make_simplify_tool(self.model, self.logger)

    @property
    def simplify(self) -> BaseTool:
        return self._simplify_tool

    @property
    def brainstorm(self) -> BaseTool:
        return self._brainstorm_tool

    def get_tools(self):
        """Return a list of all tool callables."""
        return [self._brainstorm_tool, self._simplify_tool]

    def get_all(self, enabled_tools: list[str] = None) -> list:
        """Return a list of tools, optionally filtered by enabled_tools."""
        all_tools = [self._brainstorm_tool, self._simplify_tool]
        if enabled_tools:
            return self.filter_tools_by_names(enabled_tools)
        return all_tools

    def filter_tools_by_names(self, tool_names: list[str]) -> list:
        """Return only tools whose name is in tool_names."""
        return [tool for tool in self.get_all() if tool.name in tool_names]

    @staticmethod
    def list_tool_metadata(lang: str = "Deutsch") -> ToolListResponse:
        """
        Dynamically returns metadata for all available tools, including their name and description, without requiring a model.
        Args:
            lang (str, optional): The language for the tool metadata. Defaults to "Deutsch".
        Returns:
            ToolListResponse: An object containing a list of ToolInfo instances, each representing a tool's id, name, and description.
        """

        class DummyModel(RunnableSerializable):
            def with_config(self, *args, **kwargs):
                return self

            def with_structured_output(self, *args, **kwargs):
                return self

            def __init__(self):
                self.__pregel_runtime = {}

            def invoke(self, *args, **kwargs):
                return type("DummyResponse", (), {"content": ""})()

        dummy_logger = getLogger(
            name="dummy"
        )  # Define tool metadata with languages as top-level keys
        tool_metadata = {
            "deutsch": {
                "Brainstorming": {
                    "name": "Brainstorming",
                    "description": "Erstellt oder verbessert eine detaillierte Mindmap zu einem Thema im Markdown-Format, basierend auf Nutzer-Feedback.",
                },
                "Vereinfachen": {
                    "name": "Vereinfachen",
                    "description": "Vereinfacht komplexe deutsche Texte auf A2-Niveau nach Prinzipien der Leichten Sprache.",
                },
            },
            "english": {
                "Brainstorming": {
                    "name": "Brainstorming",
                    "description": "Generates or refines a detailed mind map for a given topic in markdown format based on user feedback.",
                },
                "Vereinfachen": {
                    "name": "Simplify",
                    "description": "Simplifies complex German text to A2 level using Easy Language principles.",
                },
            },
            "français": {
                "Brainstorming": {
                    "name": "Remue-méninges",
                    "description": "Génère ou améliore une carte mentale détaillée pour un sujet donné au format markdown selon les commentaires de l'utilisateur.",
                },
                "Vereinfachen": {
                    "name": "Simplifier",
                    "description": "Simplifie les textes allemands complexes au niveau A2 selon les principes du langage facile.",
                },
            },
            "bairisch": {
                "Brainstorming": {
                    "name": "Brainstorming",
                    "description": "Macht a genaue Mindmap zu am Thema im Markdown-Format oder verbessert eine, wenn da Nutzer Feedback gibt.",
                },
                "Vereinfachen": {
                    "name": "Eifacher machen",
                    "description": "Macht schwere deutsche Text eifacher auf A2-Level mit da Leichten Sprach.",
                },
            },
            "ukrainisch": {
                "Brainstorming": {
                    "name": "Мозковий штурм",
                    "description": "Створює або вдосконалює детальну ментальну карту для заданої теми у форматі markdown на основі відгуків користувачів.",
                },
                "Vereinfachen": {
                    "name": "Спростити",
                    "description": "Спрощує складні німецькі тексти до рівня A2 за принципами простої мови.",
                },
            },
        }

        # Determine language key
        lang_key = "deutsch"
        if lang.lower() == "english":
            lang_key = "english"
        elif lang.lower() in ["français", "francais", "french"]:
            lang_key = "français"
        elif lang.lower() in ["bairisch", "bavarian", "bayerisch"]:
            lang_key = "bairisch"
        elif lang.lower() in ["українська", "ukrainisch", "ukrainian"]:
            lang_key = "ukrainisch"

        # Create tool instances
        brainstorm_tool = make_brainstorm_tool(DummyModel(), dummy_logger)
        simplify_tool = make_simplify_tool(DummyModel(), dummy_logger)

        # Build the list using actual tool names for lookup
        tools = []
        for tool_id in [brainstorm_tool, simplify_tool]:
            tool_name = tool_id.name
            meta = tool_metadata.get(lang_key, {}).get(tool_name)
            if meta:
                tools.append(
                    ToolInfo(
                        id=tool_name,
                        name=meta.get("name", tool_name),
                        description=meta.get("description", tool_id.description),
                    )
                )
            else:
                # fallback to tool's own name/description
                tools.append(
                    ToolInfo(
                        id=tool_name, name=tool_name, description=tool_id.description
                    )
                )
        return ToolListResponse(tools=tools)

    def add_instructions(self, messages, enabled_tools):
        """Inject a system message describing available tools with concise summaries and detailed guidance."""
        if not enabled_tools:
            return messages

        # Map tool name to detailed block
        detailed_map = {
            "Brainstorming": brainstorm.BRAINSTORMING_DETAILED,
            "Vereinfachen": simplify.SIMPLIFY_DETAILED,
        }

        tool_descriptions = []  # single-line summaries
        tool_detailed_instructions = []

        for t in enabled_tools:
            tool_obj = None
            if hasattr(t, "name") and hasattr(t, "description"):
                tool_obj = t
            else:
                tool_obj = next(
                    (tool for tool in self.get_all() if tool.name == t), None
                )
            if not tool_obj:
                continue
            summary = tool_obj.description.strip().replace("\n", " ")
            tool_descriptions.append(f"- {tool_obj.name}: {summary}")
            detailed = detailed_map.get(tool_obj.name)
            if detailed:
                tool_detailed_instructions.append(detailed.strip())

        if not tool_descriptions:
            return messages

        tool_instructions = TOOL_INSTRUCTIONS_TEMPLATE.format(
            tool_descriptions="\n".join(tool_descriptions),
            tool_detailed_instructions="\n\n".join(tool_detailed_instructions),
        )

        if messages and isinstance(messages[0], SystemMessage):
            messages[0] = SystemMessage(
                content=f"{messages[0].content}\n\n{tool_instructions}"
            )
        else:
            messages.insert(0, SystemMessage(content=tool_instructions))
        return messages
